标定逻辑

1. 设置设备类型及标定/复检
2. 读取border及calib图片（以灰度图方式）
3. 获取光机的小方格和标定板小圆点图片
4. 根据border生成绿色网格





设备类型

1. 设备类型；
2. 设备对应的各种参数；
   1. 标定点个数；
   2. 光机投的标定点图
3. 生成设备类型对应的标定图
   1. 确定各个标定点的坐标
      1. 使用np.mgird生成二维坐标系，从而确定各个标定点的坐标
   2. 以各个标定点的坐标为中心画矩形



生成绿色网格图

1. 获得border图

2. 对border图进行高斯降噪

3. 对上一步的图像分别在横向及纵向进行卷积操作，实现边缘检测

   1. 处理上述得到的浮点数据

      1. 具体地说，`cv.convertScaleAbs` 函数的工作流程如下：
      2. 将浮点型的数据类型转换为 8 位整数型。
      3. 将每个像素乘以一个尺度因子（scale factor），通常为 1 或原始值的某个分数，以便压缩输出范围。
      4. 削减低于零的像素值，使它们都等于零。
      5. 削减大于 255 的像素值（如果有），使它们都等于 255。
      6. 最后，将任何剩余像素舍入到最接近的整数值上。

      通过使用 `cv.convertScaleAbs`，我们将浮点值映射到 [0, 255] 的整数值范围内，可以方便地将其进行显示或保存。

   2. otsu自适应阈值二值化图片

      - otsuThreshold

        1. 如果是彩色图片，转换成灰度图片
        2. 高斯滤波去噪
        3. 灰度值小于设定值的全赋值为设定值，大于设定值的全赋值为设定值
        4. 然后进行otsu二值化，根据ostu计算出来的阈值，大于该阈值的赋值为255，小于该阈值的赋值为0。

4. 将横向和纵向上的梯度运算计算结果进行加权叠加

5. 执行形态学运算中的闭操作对图像进行处理，形态学闭操作可以用于去除前景中的小孔洞，填补前景物体中的小缺口，并且能够消除毛刺和极端小的斑点等。通过将闭操作应用于图像的情况，可以有效地平滑边缘并删除细节信息，从而更好地提取特征

6. 识别轮廓

7. 对识别到的多个轮廓按照周长排序，选出周长小的轮廓

8. 找到最小矩形的几何中心坐标，矩形的长和宽，旋转角度

9. 根据border矩形框的像素大小和真实物理尺寸大小，获取图片中像素和真实物理大小比率approx_pixel_mm_ratio

10. 找到对应关系，CS的标定图中1个像素在相机照片中对应多少像素面积（1个小方格有12个像素），小方格的像素面积，标定板中黑点大小在相机照片中对应多少像素面积

11. 根据最小矩形的几何中心坐标，旋转角度，确定旋转矩阵

12. 确定相机图片中上下左右四个角的坐标分别离识别到的矩形轮廓的四个角的距离大小，并找到识别到的矩形轮廓的四个角距离相机图片中上下左右四个角最小的那个点（从而才能和相机图片轮廓四个角和识别到的矩形轮廓四个角一一对应，确定左上，左下，右上，右下四个角）

13. 将左上角点2维坐标增加1个数，变成3维，和旋转矩阵相乘

14. 将最小矩形的宽和高分别除以标定图的数量，均分，确定单条绿色网格的宽度和高度

15. 确定网格的左上角坐标（将最小矩形的左上角点在x和y方向分别移动半个网格大小）和右下角坐标（将最小矩形的右下角点在x和y方向分别移动半个网格大小）

16. 然后分别在横向和纵向上画线

17. 建立一个和之前的旋转矩阵相反方向的旋转矩阵，并应用在生成的绿色网格图片上，进行仿射变换成和相机大小一致的图片

18. 然后转换成无符号的8位整型数









标定

1. 根据设备类型获取标定板参数

标定板参数：

CS

```
        self.__cb.name = 'CS'
        self.__cb.gsize = (16, 16)
        self.__cb.gap_mm = (4.68, 8.32)
        self.__cb.shape = (1080, 1920)
        self.__cb.real_shape = (70.2, 124.8)
        self.__cb.mm_pixel = self.__cb.real_shape[1] / self.__cb.shape[1]
        self.__cb.square_size = (12, 12)
        self.__cb.black_spot_diameter = 0.5
        self.__cb.points = self.__gen_pnts(self.__cb.shape, self.__cb.gsize, self.__cb.square_size[0] / 2)#生成标定图的各个点坐标
        self.__cb.image = self.__gen_image(self.__cb.shape, self.__cb.points, self.__cb.square_size)#使用上面的坐标，使用矩形方法绘制标定图
```

A2D

```
        self.__cb.name = 'A2D'
        self.__cb.gsize = (16, 16)
        self.__cb.gap_mm = (5.4, 9.6)
        self.__cb.shape = (1080, 1920)
        self.__cb.real_shape = (81, 144)
        self.__cb.mm_pixel = self.__cb.real_shape[1] / self.__cb.shape[1]
        self.__cb.square_size = (6, 6)
        self.__cb.black_spot_diameter = 0.5
        self.__cb.points = self.__gen_pnts(self.__cb.shape, self.__cb.gsize, self.__cb.square_size[0] / 2)
        self.__cb.image = self.__gen_image(self.__cb.shape, self.__cb.points, self.__cb.square_size)
```



1. 根据border和标定图和标定板上点数划分提取黑点和白点

   - extract_pnts提取点：返回一个类，里面有作用了旋转矩阵的中心部分点，旋转角度和中心点和大图

     - selectROI：根据border图范围，确定calib图片中需要的范围，裁剪掉不需要的区域

       - 对border图进行高斯降噪

       - 对上一步的图像分别在横向及纵向进行卷积操作，实现边缘检测

         1. 处理上述得到的浮点数据

            1. 具体地说，`cv.convertScaleAbs` 函数的工作流程如下：
            2. 将浮点型的数据类型转换为 8 位整数型。
            3. 将每个像素乘以一个尺度因子（scale factor），通常为 1 或原始值的某个分数，以便压缩输出范围。
            4. 削减低于零的像素值，使它们都等于零。
            5. 削减大于 255 的像素值（如果有），使它们都等于 255。
            6. 最后，将任何剩余像素舍入到最接近的整数值上。

            通过使用 `cv.convertScaleAbs`，我们将浮点值映射到 [0, 255] 的整数值范围内，可以方便地将其进行显示或保存。

         2. otsu自适应阈值二值化图片

            - otsuThreshold

              1. 如果是彩色图片，转换成灰度图片
              2. 高斯滤波去噪
              3. 灰度值小于设定值的全赋值为设定值，大于设定值的全赋值为设定值
              4. 然后进行otsu二值化，根据ostu计算出来的阈值，大于该阈值的赋值为255，小于该阈值的赋值为0。

       - 将横向和纵向上的梯度运算计算结果进行加权叠加

       - 执行形态学运算中的闭操作对图像进行处理，形态学闭操作可以用于去除前景中的小孔洞，填补前景物体中的小缺口，并且能够消除毛刺和极端小的斑点等。通过将闭操作应用于图像的情况，可以有效地平滑边缘并删除细节信息，从而更好地提取特征

       - 识别轮廓

       - 对识别到的多个轮廓按照周长排序，选出周长小的轮廓

       - 找到最小矩形的几何中心坐标，矩形的长和宽，旋转角度

       - 确定相机图片中上下左右四个角的坐标分别离识别到的矩形轮廓的四个角的距离大小，并找到识别到的矩形轮廓的四个角距离相机图片中上下左右四个角最小的那个点（从而才能和相机图片轮廓四个角和识别到的矩形轮廓四个角一一对应，确定左上，左下，右上，右下四个角）

       - 将左上角点2维坐标增加1个数，变成3维，和旋转矩阵相乘

       - 将最小矩形的宽和高分别除以标定图的数量，均分，确定单条绿色网格的宽度和高度

       - 确定网格的左上角坐标（将最小矩形的左上角点在x和y方向分别移动半个网格大小）和右下角坐标（将最小矩形的右下角点在x和y方向分别移动半个网格大小）

       - 然后对标定图进行高斯去噪

       - 使用上面的旋转矩阵作用于标定图

       - 根据矩形轮廓四个角的的坐标，对标定图取四个角内的的部分。

     - extract_pnts_with_mesh：获得的所有的轮廓的中心点在原calib上的坐标和大图再进行处理

       - 将calib图片切割成想要的区域roi大小之后，根据标定点多少，需要确定划分成多少行多少列的网格，从而得到单行单列的高和宽
       - 确定单行单列的高和宽和行和列的网格数相乘后不会超过原roi区域，若超过，需要将roi补起来，若不超过，去掉多余的部分。
       - 将roi切割成16x16的网格，一个大list中有16个list，每个list中又有16个list。list中的元素即为该cell的灰度值
       - 设定目标识别参数，比如面积比，填充比等待
       - 对每个cell进行处理
         - maxHistGray：找到灰度值数量最多的那个灰度值，即为背景灰度值
         - otsuThreshold：识别黑点时，背景灰度值设为最大阈值，大于最大阈值的，像素点灰度值变为该值；识别白点时，背景灰度值设为最小阈值，小于最小阈值的，像素点灰度值变为该值
           - 识别黑点时，将白点的灰度值赋值为和背景一致，然后二值化，此时黑点部分变成0，背景部分变成255.然后取反，使黑点部分变白，白色背景变黑。
           - 识别白点时，将黑点的灰度赋值为和背景一致，然后二值化，此时白点部分变成255，背景部分变成0.
         - process_helper：根据处理后的cell和识别条件，获取cell中识别到的轮廓的中心点，并创建新图幅，将圆画出来。并把中心点和图一起传回去
           - algorithm_handler：获取cell中识别到的轮廓的中心点
             - AdaThreshold类
               - handle：
               - process：
                 - Handler类
                   - detect_pnts
                     - locate_centriod
                       - 转换为灰度图
                       - 生成内核然后进行形态学操作
                       - 识别轮廓
                       - 对所有轮廓进行识别条件判断，选出正确轮廓的中心点
           - 找到每个cell的左上角的坐标
           - 将中心点坐标和cell左上角的坐标做和，获得中心点在原calib上的坐标
           - stackImages
             - 将256幅创建的新的，用来画圆的图幅按照16行16列组合成一张大图

   - 将获得的所有的轮廓的中心点在原calib上的坐标和大图再进行处理

     - transform_pnts：返回作用了旋转矩阵后的点
       - get_roi_pnts：减少行数和列数，只要中心部分的点
         - decay_invalid_pnts
           - 减少行数和列数
       - 计算剩下的点的平均值，即中心坐标
       - fit2dMatrixAngleHelper：根据行和列的旋转角度计算旋转情况
         - fitLineAngle_ex：将中心部分的点按每一行处理，每一行的点进行两两组合，然后变成向量，转换到极坐标系下，看各个向量的角度和长度，返回所有向量的平均角度，即为该行的旋转情况，计算所有行的平均角度，即为行方向的旋转情况。同理计算列方向的旋转情况。对行方向和列方向的旋转情况取平均值即为整体的旋转情况。
       - 根据中心坐标和整体的旋转角度，生成旋转矩阵。
       - 对所有提取到的轮廓中心点作用旋转矩阵
       - 返回一个类，里面有作用了旋转矩阵的点，旋转角度和中心点

2. 计算偏差：根据上一步获得的黑点和白点

   - 根据标定板类型获取标定板参数
   - get_cvtcoef_pixel_mm：获取转换系数，pixel/mm
     - 标定板上行和列间距
     - get_roi_pnts：获得中心部分点
     - 计算中心部分点的每行及每列的差（像素单位）
     - 行：将像素单位的差除以标定板上行的差，对列也如此处理，然后取两者平均值，即为pixel/mm系数。
   - 计算白点中心坐标与黑点中心坐标的差，即中心偏差
   - 然后对作用了旋转矩阵的白点减去中心偏差，即将白点中心对应到黑点中心上去
   - 然后使用白点减去黑点，获得坐标差

3. 矫正偏差

   - undistorting：指定生成的图片的像素大小（和光机像素大小一致）

     - spline_mapxy

       - 获取光机投的标定图的每个方块的中心坐标，分为x坐标和y坐标

       - spline_helper：根据标定图方块中心坐标的x和y，和计算出在x方向的偏差大小

         - Spline：类，进行拟合

         - 创建一个和标定图像素大小一致的矩阵

         - 行：标定图方块每一行的中心坐标x和白黑点的坐标偏差（先拟合行）

         - 列：标定图方块每一列的中心坐标y和行拟合出来的偏差在对应列上的值

           - fit：对标定图方块每一行的中心坐标x和对应此行的白黑点的坐标偏差做拟合

             - __spline_Natural

               - 创建三次函数的系数a、b、c、d的系数矩阵
                 $$
                 a+bx+cx^2+dx^3
                 $$

           - predict

             - 创建行方向上1920个位置
             - 预测每个位置上的值

         - 返回标定板像素大小的矩阵中每个点的值均为拟合出的偏差大小，即为x方向拟合出来的每个像素的偏差。

         - 同理拟合y方向上每个像素的偏差。

       - gen_coordinates：生成每个像素点对应的坐标

       - 获得每个像素点对应坐标的偏差x，即mapx

       - 获得每个像素点对应坐标的偏差y，即mapy

     - 对标定图通过cv.remap进行作用，获取矫正后的图。

     - 返回矫正后的图，以及mapx即mapy。

   - write_calib_data：对y轴方向的偏差乘以-1后，保存为json文件

   - write_xml：将mapx及mapy保存下来

   - 返回偏差



1. 将border和calib图转换成灰度图
2. 利用border图识别出最小矩形获得中心坐标和旋转角度，将calib图进行仿射变换矫正
3. 并根据border图识别出最小矩形的长和宽选中calib中对应区域作为处理区域

extract_pnts_with_mesh

1. 根据网格的大小位置，将处理区域进行切割成和标定图中小方格数量对应一致的小块区域

maxHistGray

1. 对单个区域，进行灰度值直方图分析，确定灰度阈值，对该图片分别处理，分别获得白点和黑点的圆心坐标
   - 识别黑点时，将白点的灰度值赋值为和背景一致，然后二值化，此时黑点部分变成0，背景部分变成255.然后取反，使黑点部分变白，白色背景变黑。
   - 识别白点时，将黑点的灰度赋值为和背景一致，然后二值化，此时白点部分变成255，背景部分变成0.



1. 然后将单个区域中获取的白点和黑点坐标和该区域的左上角坐标相加，转换到全局坐标系下，也就是相机图片的坐标系下
2. 从16x16的绿色网格的左上角点中，选择中间的10x10个点阵，计算中心点及旋转角度，获得旋转矩阵
3. 对16x16黑、白点作用旋转矩阵，然后分别输出黑、白点的所有点坐标、中心及角度
4. 利用黑点的在照片中的间距和标定板上的物理间距，确定像素/mm的比例
5. 计算16x16的所有黑点和白点中心坐标偏差
6. 将16x16的所有白点矩阵减去上面的中心坐标偏差（相当于将白点对其到黑点上）
7. 将白点坐标减去黑点坐标，即为各组白点和黑点之间的坐标偏差
8. 将坐标偏差转换成mm单位（max mm dev:），以及对应的光机投图上像素偏差（max pixel dev）
9. 将16行16列的点的x方向及y方向的偏差进行样条插值
   1. 将光机源标定图的中心点分为x坐标和y坐标
   2. 将各个点对应的偏差的x坐标和光机源标定图的x坐标组合成一个元组，









