标定逻辑

1. 设置设备类型及标定/复检
2. 读取border及calib图片（以灰度图方式）
3. 获取光机的小方格和标定板小圆点图片
4. 根据border生成绿色网格





设备类型

1. 设备类型；
2. 设备对应的各种参数；
   1. 标定点个数；
   2. 光机投的标定点图
3. 生成设备类型对应的标定图
   1. 确定各个标定点的坐标
      1. 使用np.mgird生成二维坐标系，从而确定各个标定点的坐标
   2. 以各个标定点的坐标为中心画矩形



生成绿色网格图

1. 获得border图

2. 对border图进行高斯降噪

3. 对上一步的图像分别在横向及纵向进行卷积操作，实现边缘检测

   1. 处理上述得到的浮点数据

      1. 具体地说，`cv.convertScaleAbs` 函数的工作流程如下：
      2. 将浮点型的数据类型转换为 8 位整数型。
      3. 将每个像素乘以一个尺度因子（scale factor），通常为 1 或原始值的某个分数，以便压缩输出范围。
      4. 削减低于零的像素值，使它们都等于零。
      5. 削减大于 255 的像素值（如果有），使它们都等于 255。
      6. 最后，将任何剩余像素舍入到最接近的整数值上。

      通过使用 `cv.convertScaleAbs`，我们将浮点值映射到 [0, 255] 的整数值范围内，可以方便地将其进行显示或保存。

   2. otsu自适应阈值二值化图片

      - otsuThreshold

        1. 如果是彩色图片，转换成灰度图片
        2. 高斯滤波去噪
        3. 灰度值小于设定值的全赋值为设定值，大于设定值的全赋值为设定值
        4. 然后进行otsu二值化，根据ostu计算出来的阈值，大于该阈值的赋值为255，小于该阈值的赋值为0。

4. 将横向和纵向上的梯度运算计算结果进行加权叠加

5. 执行形态学运算中的闭操作对图像进行处理，形态学闭操作可以用于去除前景中的小孔洞，填补前景物体中的小缺口，并且能够消除毛刺和极端小的斑点等。通过将闭操作应用于图像的情况，可以有效地平滑边缘并删除细节信息，从而更好地提取特征

6. 识别轮廓

7. 对识别到的多个轮廓按照周长排序，选出周长小的轮廓

8. 找到最小矩形的几何中心坐标，矩形的长和宽，旋转角度

9. 根据border矩形框的像素大小和真实物理尺寸大小，获取图片中像素和真实物理大小比率approx_pixel_mm_ratio

10. 找到对应关系，CS的标定图中1个像素在相机照片中对应多少像素面积（1个小方格有12个像素），小方格的像素面积，标定板中黑点大小在相机照片中对应多少像素面积

11. 根据最小矩形的几何中心坐标，旋转角度，确定旋转矩阵

12. 确定相机图片中上下左右四个角的坐标分别离识别到的矩形轮廓的四个角的距离大小，并找到识别到的矩形轮廓的四个角距离相机图片中上下左右四个角最小的那个点（从而才能和相机图片轮廓四个角和识别到的矩形轮廓四个角一一对应，确定左上，左下，右上，右下四个角）

13. 将左上角点2维坐标增加1个数，变成3维，和旋转矩阵相乘

14. 将最小矩形的宽和高分别除以标定图的数量，均分，确定单条绿色网格的宽度和高度

15. 确定网格的左上角坐标（将最小矩形的左上角点在x和y方向分别移动半个网格大小）和右下角坐标（将最小矩形的右下角点在x和y方向分别移动半个网格大小）

16. 然后分别在横向和纵向上画线

17. 建立一个和之前的旋转矩阵相反方向的旋转矩阵，并应用在生成的绿色网格图片上，进行仿射变换成和相机大小一致的图片

18. 然后转换成无符号的8位整型数



4. 
5. 





标定

1. 根据设备类型获取标定板参数

标定板参数：

CS

```
        self.__cb.name = 'CS'
        self.__cb.gsize = (16, 16)
        self.__cb.gap_mm = (4.68, 8.32)
        self.__cb.shape = (1080, 1920)
        self.__cb.real_shape = (70.2, 124.8)
        self.__cb.mm_pixel = self.__cb.real_shape[1] / self.__cb.shape[1]
        self.__cb.square_size = (12, 12)
        self.__cb.black_spot_diameter = 0.5
        self.__cb.points = self.__gen_pnts(self.__cb.shape, self.__cb.gsize, self.__cb.square_size[0] / 2)#生成标定图的各个点坐标
        self.__cb.image = self.__gen_image(self.__cb.shape, self.__cb.points, self.__cb.square_size)#使用上面的坐标，使用矩形方法绘制标定图
```

A2D

```
        self.__cb.name = 'A2D'
        self.__cb.gsize = (16, 16)
        self.__cb.gap_mm = (5.4, 9.6)
        self.__cb.shape = (1080, 1920)
        self.__cb.real_shape = (81, 144)
        self.__cb.mm_pixel = self.__cb.real_shape[1] / self.__cb.shape[1]
        self.__cb.square_size = (6, 6)
        self.__cb.black_spot_diameter = 0.5
        self.__cb.points = self.__gen_pnts(self.__cb.shape, self.__cb.gsize, self.__cb.square_size[0] / 2)
        self.__cb.image = self.__gen_image(self.__cb.shape, self.__cb.points, self.__cb.square_size)
```



1. 根据border和标定图和标定板上点数划分提取黑点和白点

   - extract_pnts提取点

     - selectROI：根据border图范围，确定calib图片中需要的范围，裁剪掉不需要的区域

       - 对border图进行高斯降噪

       - 对上一步的图像分别在横向及纵向进行卷积操作，实现边缘检测

         1. 处理上述得到的浮点数据

            1. 具体地说，`cv.convertScaleAbs` 函数的工作流程如下：
            2. 将浮点型的数据类型转换为 8 位整数型。
            3. 将每个像素乘以一个尺度因子（scale factor），通常为 1 或原始值的某个分数，以便压缩输出范围。
            4. 削减低于零的像素值，使它们都等于零。
            5. 削减大于 255 的像素值（如果有），使它们都等于 255。
            6. 最后，将任何剩余像素舍入到最接近的整数值上。

            通过使用 `cv.convertScaleAbs`，我们将浮点值映射到 [0, 255] 的整数值范围内，可以方便地将其进行显示或保存。

         2. otsu自适应阈值二值化图片

            - otsuThreshold

              1. 如果是彩色图片，转换成灰度图片
              2. 高斯滤波去噪
              3. 灰度值小于设定值的全赋值为设定值，大于设定值的全赋值为设定值
              4. 然后进行otsu二值化，根据ostu计算出来的阈值，大于该阈值的赋值为255，小于该阈值的赋值为0。

       - 将横向和纵向上的梯度运算计算结果进行加权叠加

       - 执行形态学运算中的闭操作对图像进行处理，形态学闭操作可以用于去除前景中的小孔洞，填补前景物体中的小缺口，并且能够消除毛刺和极端小的斑点等。通过将闭操作应用于图像的情况，可以有效地平滑边缘并删除细节信息，从而更好地提取特征

       - 识别轮廓

       - 对识别到的多个轮廓按照周长排序，选出周长小的轮廓

       - 找到最小矩形的几何中心坐标，矩形的长和宽，旋转角度

       - 确定相机图片中上下左右四个角的坐标分别离识别到的矩形轮廓的四个角的距离大小，并找到识别到的矩形轮廓的四个角距离相机图片中上下左右四个角最小的那个点（从而才能和相机图片轮廓四个角和识别到的矩形轮廓四个角一一对应，确定左上，左下，右上，右下四个角）

       - 将左上角点2维坐标增加1个数，变成3维，和旋转矩阵相乘

       - 将最小矩形的宽和高分别除以标定图的数量，均分，确定单条绿色网格的宽度和高度

       - 确定网格的左上角坐标（将最小矩形的左上角点在x和y方向分别移动半个网格大小）和右下角坐标（将最小矩形的右下角点在x和y方向分别移动半个网格大小）

       - 然后对标定图进行高斯去噪

       - 使用上面的旋转矩阵作用于标定图

       - 根据矩形轮廓四个角的的坐标，对标定图取四个角内的的部分。

     - extract_pnts_with_mesh：

       - 将calib图片切割成想要的区域roi大小之后，根据标定点多少，需要确定划分成多少行多少列的网格，从而得到单行单列的高和宽
       - 确定单行单列的高和宽和行和列的网格数相乘后不会超过原roi区域，若超过，需要将roi补起来，若不超过，去掉多余的部分。
       - 将roi切割成16x16的网格，一个大list中有16个list，每个list中又有16个list。list中的元素即为该cell的灰度值
       - 设定目标识别参数，比如面积比，填充比等待
       - 对每个cell进行处理
         - maxHistGray：找到灰度值数量最多的那个灰度值，即为背景灰度值
         - otsuThreshold：识别黑点时，背景灰度值设为最大阈值，大于最大阈值的，像素点灰度值变为该值；识别白点时，背景灰度值设为最小阈值，小于最小阈值的，像素点灰度值变为该值
           - 识别黑点时，将白点的灰度值赋值为和背景一致，然后二值化，此时黑点部分变成0，背景部分变成255.然后取反，使黑点部分变白，白色背景变黑。
           - 识别白点时，将黑点的灰度赋值为和背景一致，然后二值化，此时白点部分变成255，背景部分变成0.
         - process_helper：根据处理后的cell和识别条件，获取cell中识别到的轮廓的中心点，并创建新图幅，将圆画出来。并把中心点和图一起传回去
           - algorithm_handler：获取cell中识别到的轮廓的中心点
             - AdaThreshold类
               - handle：
               - process：
                 - Handler类
                   - detect_pnts
                     - locate_centriod
                       - 转换为灰度图
                       - 生成内核然后进行形态学操作
                       - 识别轮廓
                       - 对所有轮廓进行识别条件判断，选出正确轮廓的中心点
           - 找到每个cell的左上角的坐标
           - 将中心点坐标和cell左上角的坐标做和，获得中心点在原calib上的坐标
           - stackImages
             - 将256幅创建的新的，用来画圆的图幅按照16行16列组合成一张大图

   - 将获得的所有的轮廓的中心点在原calib上的坐标和大图再进行处理

     - transform_pnts

       - get_roi_pnts：减少行数和列数，只要中心部分的点
         - decay_invalid_pnts
           - 减少行数和列数
       - 计算剩下的点的平均值，即中心坐标
       - fit2dMatrixAngleHelper
         - fitLineAngle_ex：将中心部分的点按每一行处理，每一行的点进行两两组合，然后变成向量，转换到极坐标系下，看各个向量的角度和长度，返回各个向量的平均角度
         - 

       





1. 将border和calib图转换成灰度图
2. 利用border图识别出最小矩形获得中心坐标和旋转角度，将calib图进行仿射变换矫正
3. 并根据border图识别出最小矩形的长和宽选中calib中对应区域作为处理区域

extract_pnts_with_mesh

1. 根据网格的大小位置，将处理区域进行切割成和标定图中小方格数量对应一致的小块区域

maxHistGray

1. 对单个区域，进行灰度值直方图分析，确定灰度阈值，对该图片分别处理，分别获得白点和黑点的圆心坐标
   - 识别黑点时，将白点的灰度值赋值为和背景一致，然后二值化，此时黑点部分变成0，背景部分变成255.然后取反，使黑点部分变白，白色背景变黑。
   - 识别白点时，将黑点的灰度赋值为和背景一致，然后二值化，此时白点部分变成255，背景部分变成0.



1. 然后将单个区域中获取的白点和黑点坐标和该区域的左上角坐标相加，转换到全局坐标系下，也就是相机图片的坐标系下
2. 从16x16的绿色网格的左上角点中，选择中间的10x10个点阵，计算中心点及旋转角度，获得旋转矩阵
3. 对16x16黑、白点作用旋转矩阵，然后分别输出黑、白点的所有点坐标、中心及角度
4. 利用黑点的在照片中的间距和标定板上的物理间距，确定像素/mm的比例
5. 计算16x16的所有黑点和白点中心坐标偏差
6. 将16x16的所有白点矩阵减去上面的中心坐标偏差（相当于将白点对其到黑点上）
7. 将白点坐标减去黑点坐标，即为各组白点和黑点之间的坐标偏差
8. 将坐标偏差转换成mm单位（max mm dev:），以及对应的光机投图上像素偏差（max pixel dev）
9. 将16行16列的点的x方向及y方向的偏差进行样条插值
   1. 将光机源标定图的中心点分为x坐标和y坐标
   2. 将各个点对应的偏差的x坐标和光机源标定图的x坐标组合成一个元组，



extract_pnts

extract_pnts_with_mesh





transform_pnts

1. 从16x16的绿色网格的左上角点中，选择中间的10x10个点阵，计算中心点及旋转角度，获得旋转矩阵
2. 对黑、白点作用旋转矩阵，然后分别输出黑、白点的所有点坐标、中心及角度



